##### Java 运行时数据区域

JVM 在运行的过程中，会把它的内存分成不同的区域，根据是否是线程私有的角度划分：

线程共享数据区：堆、方法区

线程隔离数据区：程序计数器、虚拟机栈、本地方法栈。

- 程序计数器

  因为多线程情况下，每个线程都会轮流切换使用处理器。在线程切换恢复后，需要从正确的行号继续执行。它可以看做是当前线程所执行的字节码的行号指示器。

- 虚拟机栈

  虚拟机栈描述的是 Java 方法执行的内部模型，每个方法在执行的时候回创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表中存放了各种基本数据类型、对象引用等类型。

- 本地方法栈

  本地方法栈与虚拟机栈作用是相似的，虚拟机栈是为执行 Java 方法服务，本地方法栈是为虚拟机用的 Native 方法服务。

- 堆

  Java 堆是虚拟机所管理的内存中最大的一块，被所有线程共享。在虚拟机启动的时候创建，用于存放对象实例。

  根据分代垃圾收集算法，Java 堆可以分为新生代、老生代，其中新生代还可以细分为 Eden 空间、From Survivor 空间、To Survivor 空间。

- 方法区

  方法区用于存放已被 JVM 加载的类信息，静态变量，常量，即时编译器编译后的代码等数据。运行时常量池是方法区的一部分， 用于存放编译期生成的各种字面量和符号引用。

##### 类加载器和类加载过程

类被虚拟机加载开始的生命周期共有以下几个阶段：

加载——连接（验证-准备-解析）——初始化——使用——卸载

开始加载过程的有且仅有的几种情况：

1. 当通过 new 实例化对象、读取或设置类静态字段（被 final 修饰的已经在编译期把结果放入常量池）、调用类的静态方法时，如果类没有进行过初始化，则需要先触发初始化。
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化。
3. 当初始化一个类的时候，其父类还没有进行过初始化，则先触发父类的初始化
4. 当虚拟机启动时，用户需要制定一个要执行的主类（main方法）

类加载的全过程是：加载——验证——准备——解析——初始化

- 加载

  在加载的过程中，虚拟机需要完成三件事：

  1. 通过类的全限定名来获取定义此类的二进制字节流
  2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

- 验证

  这一阶段是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，包括：

  1. 文件格式验证：符合 Class 文件格式规范
  2. 元数据验证：符合 Java 语法规范
  3. 字节码验证：数据类型等转换规范

- 准备

  正式为类变量分配内存并设置类变量初始值。此时进行内存分配的仅包括类变量（static 修饰），不包括实例变量。实例变量是在对象实例化时随着对象一起分配在 Java 堆中。

- 解析

  将常量池内的符号引用替换为直接引用的过程。

- 初始化

  在准备阶段，类变量已经被赋值过一次默认的初始值，但在初始化阶段才会设置为代码中设置的初始值。

##### 类加载器和双亲委派模型

虚拟机把类加载阶段的"通过类的全限定名来获取定义此类的二进制字节流"，放到外部实现，让应用程序自己获取需要的类，实现这个动作的代码模块称为“类加载器”。大部分 Java 程序会使用三种系统提供的类加载器：

1. 启动类加载器

   负责加载\<JAVA_HOME>\lib下的类，无法被 Java 程序直接引用。

2. 扩展类加载器

   负责加载\<JAVA_HOME>\lib\ext下的类。

3. 应用程序类加载器

   这个类加载器是 ClassLoader 中 getSystemClassLoader() 方法的返回值，一般也称为系统类加载器。

双亲委派模型要求除了顶层的启动类加载器，其余的类加载器都应该有自己的父类加载器。一个类加载器会先用父类尝试加载 Class 文件，只有父类加载器处理不了，才自己加载。以此保证对于一个 Class 文件在不同的环境下都是同一个类。

##### 垃圾收集算法演变

Java 对象实例都存放在 Java 堆中，所以垃圾回收主要发生在这个数据区域。

对于垃圾收集算法，首先要确认哪些对象需要回收：

- 引用计数算法

  给对象添加一个引用计数器，当对象被引用的时候，计数器就加1，当引用失效的时候，计数器就减1。当计数器为 0 的对象就是可以被回收的。

- 可达性分析算法

  首先定义一系列“GC Roots”的对象作为起始点，从这个节点向下搜索，搜索所走过的路径称为引用链，当一个对象不在任何引用链中，那么这个对象就是不可达的，可以被回收。

  可以被定义为“GC Roots”的对象有：

  1. 虚拟机栈中引用的对象；
  2. 方法区中的类静态属性引用的对象；
  3. 方法区中常量引用的对象；
  4. 本地方法方法栈中 Native 引用的对象。 

被判定为需要回收的对象，会被第一次标记，并进行一次筛选，筛选条件是此对象有没有重写 finalize() 方法或有没有执行过。如果 finalize() 没有重写或已经执行过一次，就进行第二次标记进入回收集合。

对已经进入回收集合的对象需要执行垃圾收集算法，常见的算法有：

- 标记-清理

  首先标记处所有需要回收的对象，然后统一回收被标记的对象。但这个方法效率不高，还会产生大量的内存碎片。

- 复制

  将内存分为大小相等的两块，每次只使用其中一块。当一块使用完，就把存活的对象复制到另外一块上，再把使用的一块空间全部清理。但这种方法内存使用率不高

- 标记-整理

  首先标记处所有需要回收的对象，然后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

- 分代收集

  根据对象存活周期的不同，将内存划分为新生代、老生代。在新生代，使用复制算法，在老年代使用标记-清理或者标记整理算法。由于新生代使用了复制算法，所以新生代可以细分为 Eden 块和两个 Survivor 块。

##### 四种引用

在引用计数算法或可达性算法中，都会有引用失效的情况。引用被分为了强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）

- 强引用

  是程序中普遍存在的，只要强引用在，垃圾收集器就不会回收掉被引用的对象。

- 软引用

  用来描述一些还有用还并非必须的对象，对于软引用关联的对象，在系统内存发生溢出异常之前，会把这些对象列进回收范围内。

- 弱引用

  用来描述給必须的对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，会回收这些对象。

- 虚引用

  一个对象是否有虚引用的存在，并不会影响垃圾回收，它的目的只是在对象被垃圾回收时收到一个通知。